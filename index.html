<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>6x5 ドロップゲーム</title>
  <style>
    /* グリッド設定 */
    #grid {
      display: grid;
      grid-template-columns: repeat(6, 50px); /* 6列、1セル50px */
      grid-template-rows: repeat(5, 50px); /* 5行、1セル50px */
      gap: 5px; /* セル間の隙間 */
      position: relative;
      border: 2px solid #000;
      margin: 20px auto;
      width: max-content;
    }

    /* ドロップの設定 */
    .drop {
      width: 50px;
      height: 50px;
      background-size: cover;
      border-radius: 5px;
      position: relative;
    }

    .drop[data-type="fire"] {
      background-image: url('火.jpg');
    }

    .drop[data-type="water"] {
      background-image: url('水.jpg');
    }

    .drop[data-type="wood"] {
      background-image: url('木.jpg');
    }

    .drop[data-type="light"] {
      background-image: url('光.jpg');
    }

    .drop[data-type="dark"] {
      background-image: url('闇.jpg');
    }

    /* ドラッグ中のスタイル */
    .dragging {
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div id="grid"></div>

  <script>
    // グリッド設定
    const gridRows = 5; // 行数
    const gridCols = 6; // 列数
    const grid = document.getElementById("grid");

    // ドロップ初期配置
    const dropTypes = ["fire", "water", "wood", "light", "dark"];
    const gridState = []; // グリッドの状態を保持する配列

    // グリッドにドロップをランダム配置
    for (let row = 0; row < gridRows; row++) {
      const rowState = [];
      for (let col = 0; col < gridCols; col++) {
        const type = dropTypes[Math.floor(Math.random() * dropTypes.length)];
        const drop = document.createElement("div");
        drop.classList.add("drop");
        drop.dataset.type = type;
        drop.dataset.row = row;
        drop.dataset.col = col;

        drop.draggable = true; // ドラッグ可能
        grid.appendChild(drop);
        rowState.push(type); // 状態に追加
      }
      gridState.push(rowState);
    }

    let selectedDrop = null;

    // ドロップをドラッグ開始
    grid.addEventListener("dragstart", (e) => {
      if (e.target.classList.contains("drop")) {
        selectedDrop = e.target;
        selectedDrop.classList.add("dragging");
      }
    });

    // ドロップをドラッグ終了
    grid.addEventListener("dragend", () => {
      if (selectedDrop) {
        selectedDrop.classList.remove("dragging");
        selectedDrop = null;
      }
    });

    // ドロップをドロップ先に置く
    grid.addEventListener("dragover", (e) => {
      e.preventDefault();
      const targetDrop = e.target;

      // ドロップ先が有効な場所かチェック
      if (targetDrop.classList.contains("drop") && targetDrop !== selectedDrop) {
        const targetRow = parseInt(targetDrop.dataset.row, 10);
        const targetCol = parseInt(targetDrop.dataset.col, 10);

        const selectedRow = parseInt(selectedDrop.dataset.row, 10);
        const selectedCol = parseInt(selectedDrop.dataset.col, 10);

        // 隣接セルのみ交換可能
        const isAdjacent =
          (Math.abs(selectedRow - targetRow) === 1 && selectedCol === targetCol) ||
          (Math.abs(selectedCol - targetCol) === 1 && selectedRow === targetRow);

        if (isAdjacent) {
          // 位置を交換
          [selectedDrop.dataset.row, targetDrop.dataset.row] = [targetDrop.dataset.row, selectedDrop.dataset.row];
          [selectedDrop.dataset.col, targetDrop.dataset.col] = [targetDrop.dataset.col, selectedDrop.dataset.col];

          // スタイルの位置を交換
          grid.insertBefore(selectedDrop, targetDrop);
        }
      }
    });
  </script>
</body>
</html>
